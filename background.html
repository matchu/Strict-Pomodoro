<html>
  <script>
    // TODO: create PREFS module

    /*

      Constants

    */

    var PREFS = loadPrefs(),
    BADGE_BACKGROUND_COLORS = {
      work: [192, 0, 0, 255],
      break: [0, 192, 0, 255]
    }, RING = new Audio("http://www.matchusian.com/strict_pomodoro/ring.mp3"),
    ringLoaded = false;
    
    loadRingIfNecessary();
    
    function defaultPrefs() {
      return {
        domainBlacklist: [
          'facebook.com',
          'youtube.com',
          'twitter.com',
          'myspace.com',
          'livejournal.com',
          'digg.com',
          'reddit.com',
          'kongregate.com',
          'newgrounds.com',
          'addictinggames.com',
          'hulu.com'
        ],
        durations: { // in seconds
          work: 25 * 60,
          break: 5 * 60
        },
        shouldRing: true,
        clickResets: false
      }
    }
    
    function loadPrefs() {
      if(typeof localStorage['prefs'] !== 'undefined') {
        return JSON.parse(localStorage['prefs']);
      } else {
        return savePrefs(defaultPrefs());
      }
    }
    
    function savePrefs(prefs) {
      localStorage['prefs'] = JSON.stringify(prefs);
      return prefs;
    }
    
    function setPrefs(prefs) {
      PREFS = savePrefs(prefs);
      loadRingIfNecessary();
      return prefs;
    }

    function loadRingIfNecessary() {
      console.log('is ring necessary?');
      if(PREFS.shouldRing && !ringLoaded) {
        console.log('ring is necessary');
        RING.onload = function () {
          console.log('ring loaded');
          ringLoaded = true;
        }
        RING.load();
      }
    }

    var ICONS = {
      ACTION: {
        CURRENT: {},
        PENDING: {}
      },
      FULL: {},
    }, iconTypeS = ['default', 'work', 'break'],
      iconType;
    for(var i in iconTypeS) {
      iconType = iconTypeS[i];
      ICONS.ACTION.CURRENT[iconType] = "icons/" + iconType + ".png";
      ICONS.ACTION.PENDING[iconType] = "icons/" + iconType + "_pending.png";
      ICONS.FULL[iconType] = "icons/" + iconType + "_full.png";
    }

    /*

      Models

    */

    function Pomodoro(options) {
      this.mostRecentMode = 'break';
      this.nextMode = 'work';
      this.running = false;

      this.onTimerEnd = function (timer) {
        this.running = false;
      }

      this.start = function () {
        var mostRecentMode = this.mostRecentMode, timerOptions = {};
        this.mostRecentMode = this.nextMode;
        this.nextMode = mostRecentMode;

        for(var key in options.timer) {
          timerOptions[key] = options.timer[key];
        }
        timerOptions.type = this.mostRecentMode;
        timerOptions.duration = options.getDurations()[this.mostRecentMode];
        this.running = true;
        this.currentTimer = new Pomodoro.Timer(this, timerOptions);
        this.currentTimer.start();
      }
      
      this.restart = function () {
          if (this.currentTimer)
              this.currentTimer.restart();
      }
    }

    Pomodoro.Timer = function Timer(pomodoro, options) {
      var tickInterval, timer = this;
      this.pomodoro = pomodoro;
      this.timeRemaining = options.duration;
      this.type = options.type;

      this.start = function () {
        tickInterval = setInterval(tick, 1000);
        options.onStart(timer);
        options.onTick(timer);
      }
      
      this.restart = function() {
          this.timeRemaining = options.duration;
          options.onTick(timer);
      }

      this.timeRemainingString = function () {
        if(this.timeRemaining >= 60) {
          return Math.round(this.timeRemaining / 60) + "m";
        } else {
          return (this.timeRemaining % 60) + "s";
        }
      }

      function tick() {
        timer.timeRemaining--;
        options.onTick(timer);
        if(timer.timeRemaining <= 0) {
          clearInterval(tickInterval);
          pomodoro.onTimerEnd(timer);
          options.onEnd(timer);
        }
      }
    }

    /*

      Views

    */

    // The code gets really cluttered down here. Refactor would be in order,
    // but I'm busier with other projects >_<

    function locationsMatch(location, blacklistedPattern) {
      return domainsMatch(location.domain, blacklistedPattern.domain) &&
        pathsMatch(location.path, blacklistedPattern.path);
    }

    function parseLocation(location) {
      var components = location.split('/');
      return {domain: components[0], path: components[1]};
    }

    function pathsMatch(test, against) {
      /*
        index.php ~> [null]: pass
        index.php ~> index: pass
        index.php ~> index.php: pass
        index.php ~> index.phpa: fail
        /path/to/location ~> /path/to: pass
        /path/to ~> /path/to: pass
        /path/to/ ~> /path/to/location: fail
      */

      return !against || test.substr(0, against.length) == against;
    }

    function domainsMatch(test, against) {

      /*
        google.com ~> google.com: case 1, pass
        www.google.com ~> google.com: case 3, pass
        google.com ~> www.google.com: case 2, fail
        google.com ~> yahoo.com: case 3, fail
        yahoo.com ~> google.com: case 2, fail
        bit.ly ~> goo.gl: case 2, fail
        mail.com ~> gmail.com: case 2, fail
        gmail.com ~> mail.com: case 3, fail
      */

      // Case 1: if the two strings match, pass
      if(test === against) {
        return true;
      } else {
        var testFrom = test.length - against.length - 1;

        // Case 2: if the second string is longer than first, or they are the same
        // length and do not match (as indicated by case 1 failing), fail
        if(testFrom < 0) {
          return false;
        } else {
          // Case 3: if and only if the first string is longer than the second and
          // the first string ends with a period followed by the second string,
          // pass
          return test.substr(testFrom) === '.' + against;
        }
      }

    }

    function executeInTabIfBlacklisted(action, tab) {
      var file = "content_scripts/" + action + ".js", location;
      location = tab.url.split('://');
      location = parseLocation(location[1]);
      for(var k in PREFS.domainBlacklist) {
        blacklistedPattern = parseLocation(PREFS.domainBlacklist[k]);
        if(locationsMatch(location, blacklistedPattern)) {
          chrome.tabs.executeScript(tab.id, {file: file});
        }
      }
    }

    function executeInAllBlacklistedTabs(action) {
      var windows = chrome.windows.getAll({populate: true}, function (windows) {
        var tabs, tab, domain, blacklistedDomain;
        for(var i in windows) {
          tabs = windows[i].tabs;
          for(var j in tabs) {
            executeInTabIfBlacklisted(action, tabs[j]);
          }
        }
      });
    }

    var notification, mainPomodoro = new Pomodoro({
      getDurations: function () { return PREFS.durations },
      timer: {
        onEnd: function (timer) {
          chrome.browserAction.setIcon({
            path: ICONS.ACTION.PENDING[timer.pomodoro.nextMode]
          });
          chrome.browserAction.setBadgeText({text: ''});
          notification = webkitNotifications.createNotification(
            ICONS.FULL[timer.type],
            "Time's up!",
            "Time for the " + timer.pomodoro.nextMode + " phase :)"
          );
          notification.onclick = function () {
            console.log("Will get last focused");
            chrome.windows.getLastFocused(function (window) {
              chrome.windows.update(window.id, {focused: true});
            });
            this.cancel();
          };
          notification.show();
          if(PREFS.shouldRing) {
            console.log("playing ring", RING);
            RING.play();
          }
        },
        onStart: function (timer) {
          chrome.browserAction.setIcon({
            path: ICONS.ACTION.CURRENT[timer.type]
          });
          chrome.browserAction.setBadgeBackgroundColor({
            color: BADGE_BACKGROUND_COLORS[timer.type]
          });
          if(timer.type == 'work') {
            executeInAllBlacklistedTabs('block');
          } else {
            executeInAllBlacklistedTabs('unblock');
          }
          if(notification) notification.cancel();
          var tabViews = chrome.extension.getViews({type: 'tab'}), tab;
          for(var i in tabViews) {
            tab = tabViews[i];
            if(typeof tab.startCallbacks !== 'undefined') {
              tab.startCallbacks[timer.type]();
            }
          }
        },
        onTick: function (timer) {
          chrome.browserAction.setBadgeText({text: timer.timeRemainingString()});
        }
      }
    });

    chrome.browserAction.onClicked.addListener(function (tab) {
      if (mainPomodoro.running) { 
          if (PREFS.clickResets)
              mainPomodoro.restart();          
      } else
          mainPomodoro.start();
    });

    chrome.tabs.onUpdated.addListener(function (tabId, changeInfo, tab) {
      if(mainPomodoro.mostRecentMode == 'work') {
        executeInTabIfBlacklisted('block', tab);
      }
    });
  </script>
</html>

